#include <iostream>
#include <utility>
#include <iterator>
#include <random>

/* Сортировка "Пузырьком" - O(n^2) */
template <typename Type>
void bubbleSort(Type *array, std::size_t size) {
    /* Индекс i (внешний цикл) определяет начало неотсортированной
     * части массива a[i],...,a[size-1], над
     * элементами которого производится обмен значений
     * с целью поиска наименьшего элемента, помещаемого на
     * позицию a[i]. Это означает, что элементы a[0],...,a[i-1]
     * уже отсортированы и находятся на своих конечных позициях: */
    for (std::size_t i = 0; i < size; ++i)
        /* Индекс j (внутренний цикл) определяет текущую для
         * сравнения и обмена пару элементов a[j-1] и a[j] в массиве
         * a[i],...,a[size-1], начиная с a[size-1] и a[size-2] и
         * далее, вплоть до элементов a[i+1] и a[i]: */
        for (std::size_t j = size - 1; j > i; --j)
            if (array[j - 1] > array[j])
                /* Обмен значений элементов a[j-1] и a[j]: */
                std::swap(array[j - 1], array[j]);
}

/* Сортировка простыми вставками - O(n^2) */
template <typename Type>
void insertionSort(Type *array, std::size_t size) {
    /* Индекс i (внешний цикл) определяет следующий
     * для сравнения элемент a[i], то есть это означает,
     * что первые i элементов a[0],...,a[i-1]
     * уже отсортированы между собой: */
    std::size_t i;
    /* Индекс j (внутренний цикл) определяет текущий
     * элемент из элементов a[0],...,a[i-1], с которыми
     * сравнивается проверяемый элемент a[i], а также,
     * по результатам сравнений, содержит индекс нового
     * места вставки проверяемого элемента a[i]: */
    std::size_t j;
    Type checkingVal;
    for (i = 1; i < size; ++i)
        /* Проверяем, стоит ли элемент a[i] на своем месте,
         * если нет, то ищем для него новое место
         * (собственно, выполняем итерацию алгоритма): */
        if (array[i] < array[i - 1]) {
            /* Сохраняем проверяемый элемент a[i] во временном объекте
             * и перемещаем на его место a[i - 1], который больше a[i]:*/
            checkingVal = std::move(array[i]);
            array[i] = std::move(array[i - 1]);
            j = i - 1;
            /* Ищем нужное место для a[i] в отсортированном
             * массиве a[0],...,a[i-1] (перемещаемся от большего
             * элемента a[i-1] (уже проверенного) к меньшему, вплоть
             * до a[0]). Попутно сдвигаем "вправо" (к большему индексу)
             * элементы a[j], которые больше a[i], тем самым в конце цикла
             * освобождая найденное места вставки (a[j]) для элемента a[i]: */
            while (j && checkingVal < array[j - 1]) {
                array[j] = std::move(array[j - 1]);
                --j;
            }
            /* Вставляем a[i] в найденное место a[j]
             * (это либо a[0] при j = 0, либо место после
             * элемента a[j - 1], меньшего или равного a[i]): */
            array[j] = std::move(checkingVal);
        }
}

/* Сортировка выбором - O(n^2) */
template <typename Type>
void selectionSort(Type *array, std::size_t size) {
    std::size_t indexOfMin;
    /* В начале каждой итерации внешнего цикла i определяет
     * правую открытую границу левой части a[0], ..., a[i-1]
     * массива, которая уже является окончательно отсортированной: */
    for (std::size_t i = 0; i < size; ++i) {
        /* На каждой итерации мы ищем минимальный элемент
         * среди неотсортированной правой части a[i], ..., a[size - 1]
         * массива, перемещая его на место a[i], тем самым увеличивая
         * левую отсортированную часть массива на один элемент: */
        indexOfMin = i;
        /* Внутренний цикл по поиску минимального элемента среди
         * a[i], ..., a[size - 1]: */
        for (std::size_t j = i + 1; j < size; ++j)
            if (array[j] < array[indexOfMin])
                indexOfMin = j;
        /* Меняем местами a[i] и a[indexOfMin]: */
        std::swap(array[i], array[indexOfMin]);
    }
}

/* Алгоритм сортировки слиянием - O(n*log(n)) */
template <typename Type>
void mergeSort(Type *array, std::size_t size) {
    /* В тривиальном массиве нечего сортировать: */
    if (size <= 1)
        return;

    /* Размер левого массива: */
    std::size_t median = size / 2;
    /* Рекурсивный вызов для двух частей массива
     * отдельно: */
    mergeSort(array, median);
    mergeSort(array + median, size - median);

    /* Теперь в массиве содержатся две независимые
     * отсортированные части:
     * a[0], ..., a[median - 1] и
     * a[median], ..., a[size - 1].
     *
     * Теперь необходимо осуществить слияние этих
     * двух частей массива, создадим для этого
     * временный массив размера size: */
    Type *tmpArray = new Type[size];

    /* Теперь осуществляем слияние двух подмассивов.
     * Просматриваем минимальные элементы каждого
     * подмассива, сравниваем их и записываем наименьший
     * из элементов в результирующий массив до тех пор,
     * пока оба массива еще не просмотрены. Затем просто
     * копируем оставшуюся часть оставшегося массива в результирующий.
     *
     * Индексы для каждого из подмассивов и временного массива: */
    std::size_t left = 0, right = median, tmpIndex = 0;
    while (left < median && right < size)
        if (array[left] < array[right])
            tmpArray[tmpIndex++] = std::move(array[left++]);
        else
            tmpArray[tmpIndex++] = std::move(array[right++]);

    /* Если в каком-то подмассиве еще остались элементы,
     * скопируем их: */
    if (left < median)
        std::copy(std::make_move_iterator(array + left),
                  std::make_move_iterator(array + median), tmpArray + tmpIndex);
    if (right < size)
        std::copy(std::make_move_iterator(array + right),
                  std::make_move_iterator(array + size), tmpArray + tmpIndex);

    /* Наконец, копируем полностью отсортированный массив в исходный: */
    std::copy(std::make_move_iterator(tmpArray),
              std::make_move_iterator(tmpArray + size), array);
    delete[] tmpArray;
}

/* Класс, реализующий семейство алгоритмов быстрой сортировки - O(n*log(n)) */
class quickSort {
    /* Алгоритм разделения массива на две части по опорному элементу,
     * в качестве которого выбирается элемент array[size - 1].
     * В результате опорный элемент занимает свое финальное положение
     * в массиве; слева от него расположены элементы, не превосходящие
     * опорный, а справа - превосходящие: */
    template <typename Type>
    static std::size_t partition(Type *array, std::size_t begin, std::size_t end);

    /* Алгоритм разделения массива на три части по опорному элементу.
     * Аналогично фукнции partition, но помимо опорного элемента
     * финальное положение занимают все элементы, равные опорному: */
    template <typename Type>
    static void threeWayPartition(Type *array, std::size_t begin, std::size_t end,
                                  std::size_t &pivotBeg, std::size_t &pivotEnd);

    /* Функция randomPivot() может использоваться для генерации
     * случайного индекса опорного элемента массива. */
    static std::size_t randomPivot(std::size_t min, std::size_t max);

public:
    /* Основной алгоритм, реализующий сортировку: */
    template <typename Type>
    static void sort(Type *array, std::size_t begin, std::size_t end);

    /* Алгоритм, реализующий быструю сортировку с разбиением массива на три части
     * (эффективен для массивов со множеством равных элементов): */
    template <typename Type>
    static void threeWaySort(Type *array, std::size_t begin, std::size_t end);
};

std::size_t quickSort::randomPivot(std::size_t min, std::size_t max) {
    /* Установка генератора псевдослучайных чисел с зерном из программной энтропии: */
    static std::mt19937_64 generator(std::random_device{}());
    /* Распределение случайных значений в диапазоне [0,255]: */
    return std::uniform_int_distribution<unsigned short>(min, max)(generator);
}

template <typename Type>
std::size_t quickSort::partition(Type *array, std::size_t begin, std::size_t end) {
    /* В качестве опорного выбирается последний элемент массива: */
    std::size_t pivot = end - 1;
    /* Индекс j обозначает правую открытую границу левого подмассива исходного
     * массива, элементы которого не превосходят опорный элемент, т.е. все
     * элементы a[begin], ..., a[j - 1] не больше опорного элемента.
     * j = begin означает, что данный подмассив пуст. */
    std::size_t j = begin;
    /* Индекс i обозначает элемент a[i], который сравнивается с опорным на
     * данной итерации. Также i обозначает правую открытую границу правого подмассива
     * исходного массива, элементы которого больше опорного элемента. При этом во
     * время цикла индекс j обозначает левую границу данного подмассива,
     * т.е. все элементы a[j], ...., a[i - 1] больше опорного элемента.
     * Индекс i изменяется от begin до end - 2, пробегая от начального до
     * предпоследнего элемента, соответственно: */
    for (std::size_t i = begin, last = end - 1; i < last; ++i)
        /* Если a[i] больше опорного, то он уже в нужном подмассиве,
         * и в конце итерации индекс i увеличится соответствующим образом,
         * увеличив тем самым на единицу размер правого подмассива, тогда
         * как размер левого подмассива не изменяется. */
        if (array[i] <= array[pivot]) {
            /* Иначе элемент a[i] не больше опорного, поэтому необходимо
             * переместить его в соответствующий левый подмассив.
             * Поменяем местами элемент a[i] с элементом a[j],
             * обозначающим первый элемент правого подмассива, а
             * затем увеличим индекс j: */
            std::swap(array[i], array[j]);
            /* Увеличиваем индекс j, в результате чего значение,
             * изначально содержащееся в a[i], теперь будет находиться
             * в левом подмассиве в крайнем элементе a[j - 1], а крайнее левое значение
             * из правого подмассива, с которым мы обменяли значение a[i], все так
             * же будет входить в правый подмассив, но теперь как крайнее правое.
             * В результате увеличения в конце итерации индекса i получаем, что
             * размер правого подмассива не изменился, но его расположение сместилось на элемент
             * вправа, тогда как размер левого подмассива увеличился на единицу. */
            ++j;
        }

    /* Получили два подмассива:
     * элементы a[begin], ..., a[j - 1] не больше опорного a[end - 1],
     * а элементы a[j], ..., a[end - 2] больше опорного a[end - 1].
     * Поменяем местами a[j] и опорный a[end - 1], тем самым поместив
     * опорный элемент на конечное для него место a[j], как раз между
     * двумя подмассивами a[0], ...,a[j - 1] и a[j + 1], ..., a[end - 1]: */
    std::swap(array[j], array[end - 1]);

    /* Возвращаем индекс опорного элемента: */
    return j;
}

template <typename Type>
void quickSort::threeWayPartition(Type *array, std::size_t begin, std::size_t end,
                                  std::size_t &pivotBeg, std::size_t &pivotEnd) {
    /* В качестве опорного выбирается последний элемент массива: */
    std::size_t pivot = end - 1;
    /* Индекс j обозначает правую открытую границу левого подмассива исходного
     * массива, элементы которого не превосходят опорный элемент, т.е. все
     * элементы a[begin], ..., a[j - 1] не больше опорного элемента.
     * j = begin означает, что данный подмассив пуст. EqualsNum означает
     * число элементов в конце этого подмассива, которые равны опорному: */
    std::size_t j = begin, equalsNum = 0;
    /* Индекс i обозначает элемент a[i], который сравнивается с опорным на
     * данной итерации. Также i обозначает правую открытую границу правого подмассива
     * исходного массива, элементы которого больше опорного элемента. При этом во
     * время цикла индекс j обозначает левую границу данного подмассива,
     * т.е. все элементы a[j], ...., a[i - 1] больше опорного элемента.
     * Индекс i изменяется от begin до end - 2, пробегая от начального до
     * предпоследнего элемента, соответственно: */
    for (std::size_t i = begin, last = end - 1; i < last; ++i)
        /* Если a[i] больше опорного, то он уже в нужном подмассиве,
         * и в конце итерации индекс i увеличится соответствующим образом,
         * увеличив тем самым на единицу размер правого подмассива, тогда
         * как размер левого подмассива не изменяется. */
        if (array[i] <= array[pivot]) {
            /* Иначе элемент a[i] не больше опорного, поэтому необходимо
             * переместить его в соответствующий левый подмассив.
             * Поменяем местами элемент a[i] с элементом a[j],
             * обозначающим первый элемент правого подмассива, а
             * затем увеличим индекс j: */
            std::swap(array[i], array[j]);
            /* Увеличиваем индекс j, в результате чего значение,
             * изначально содержащееся в a[i], теперь будет находиться
             * в левом подмассиве в крайнем элементе a[j - 1], а крайнее левое значение
             * из правого подмассива, с которым мы обменяли значение a[i], все так
             * же будет входить в правый подмассив, но теперь как крайнее правое.
             * В результате увеличения в конце итерации индекса i получаем, что
             * размер правого подмассива не изменился, но его расположение сместилось на элемент
             * вправа, тогда как размер левого подмассива увеличился на единицу. */
            ++j;
            /* Дополнительно проверяем, равен ли перемещенный элемент опорному: */
            if (array[j - 1] == array[pivot])
                /* Если да, то увеличиваем число таких элементов и ничего больше
                 * не делаем, так как он уже находится на своем месте. */
                ++equalsNum;
            else
                if (equalsNum) {
                    /* Иначе, при условии, что в левом подмассиве уже есть элементы,
                     * равные опорному (они стоят в правой его части), и новый
                     * перемещенный элемент не равен опорному,
                     * то этот элемент необходимо переместить левее всех равных опорному.
                     * Для этого поменяем его местами с первым, равным опорному: */
                    std::swap(array[j - 1], array[j - 1 - equalsNum]);
            }
        }

    /* Получили три подмассива:
     * элементы a[begin], ..., a[j - 1 - equalsNum] меньше опорного a[end - 1];
     * элементы a[j - equalsNum], ..., a[j - 1] равны опорному a[end - 1];
     * элементы a[j], ..., a[end - 2] больше опорного a[end - 1].
     *
     * Поменяем местами a[j] и опорный a[end - 1], тем самым поместив
     * опорный элемент на конечное для него место a[j], как раз между
     * подмассивами a[j - equalsNum], ...,a[j - 1] и a[j + 1], ..., a[end - 1]: */
    std::swap(array[j], array[end - 1]);

    /* Возвращаем индексы на начальный и послеконечный элементы
     * подмассива "опорных элементов": */
    pivotBeg = j - equalsNum;
    pivotEnd = j + 1;
}

template <typename Type>
void quickSort::sort(Type *array, std::size_t begin, std::size_t end) {
    std::size_t pivot;
    /* Если массив состоит хотя бы из двух элементов: */
    while (end - begin >= 2) {
        /* partition выбирает в качестве опорного последний элемент массива,
         * поэтому выберем случайно индекс опорного и поместим элемент
         * с этим индексом на место последнего. Случайность выбора опорного
         * элемента позволяет максимизировать вероятность того, что массив
         * будет разбиваться на примерно равные части, что обеспечит оптимальную
         * ассимптотику работы алгоритма. */
        pivot = randomPivot(begin, end - 1);
        std::swap(array[pivot], array[end - 1]);
        /* Разбиваем массив по опорному элементу и получаем индекс опорного: */
        pivot = partition(array, begin, end);

        /* Чтобы ограничить требуемую для рекурсивных вызовов память
         * до O(log(n)) в худшем случае, мы будем итеративно вызывать
         * сортировку каждого подмассива (сначала первый, потом второй
         * или наборот). На каждой из итерации мы будем выбирать для сортировки
         * сначала тот подмассив, длина которого короче, что обеспечит нам
         * наименьшую глубину рекурсии: */
        if ((pivot - begin) < (end - pivot - 1)) {
            /* Подмассив a[begin], ..., a[pivot - 1]: */
            sort(array, begin, pivot);
            /* Изменяем индекс начального элемента,
             * чтобы на следующей итерации обработать второй
             * подмассив: */
            begin = pivot + 1;
        } else {
            /* Подмассив a[pivot + 1], ..., a[end - 1]: */
            sort(array, pivot + 1, end);
            /* Изменяем индекс послеконечного элемента,
             * чтобы на следующей итерации обработать второй
             * подмассив: */
            end = pivot;
        }
    }
}

template <typename Type>
void quickSort::threeWaySort(Type *array, std::size_t begin, std::size_t end) {
    std::size_t pivotBegin, pivotEnd;
    /* Если массив состоит хотя бы из двух элементов: */
    while (end - begin >= 2) {
        /* partition выбирает в качестве опорного последний элемент массива,
         * поэтому выберем случайно индекс опорного и поместим элемент
         * с этим индексом на место последнего. Случайность выбора опорного
         * элемента позволяет максимизировать вероятность того, что массив
         * будет разбиваться на примерно равные части, что обеспечит оптимальную
         * ассимптотику работы алгоритма. */
        std::swap(array[randomPivot(begin, end - 1)], array[end - 1]);
        /* Разбиваем массив по опорному элементу и получаем индекс начального
         * и послеконечного элементов подмассива, содержащего только
         * элементы, равные опорному (a[pivotBegin],..., a[pivotEnd - 1]): */
        threeWayPartition(array, begin, end, pivotBegin, pivotEnd);

        /* Чтобы ограничить требуемую для рекурсивных вызовов память
        * до O(log(n)) в худшем случае, мы будем итеративно вызывать
        * сортировку каждого подмассива (сначала первый, потом второй
        * или наборот). На каждой из итерации мы будем выбирать для сортировки
        * сначала тот подмассив, длина которого короче, что обеспечит нам
        * наименьшую глубину рекурсии: */
        if ((pivotBegin - begin) < (end - pivotEnd)) {
            /* Подмассив a[begin], ..., a[pivotBegin - 1]: */
            threeWaySort(array, begin, pivotBegin);
            /* Изменяем индекс начального элемента,
             * чтобы на следующей итерации обработать второй
             * подмассив: */
            begin = pivotEnd;
        } else {
            /* Подмассив a[pivotEnd], ..., a[end - 1]: */
            threeWaySort(array, pivotEnd, end);
            /* Изменяем индекс послеконечного элемента,
             * чтобы на следующей итерации обработать второй
             * подмассив: */
            end = pivotBegin;
        }
    }
}

/* Двоичный поиск - O(log(n)): */
template <typename Type>
std::size_t binarySearch(Type *array, std::size_t begin, std::size_t end, Type &&key) {
    std::size_t middle, savedEnd = end;
    while (begin < end) {
        /* Выбираем середину [begin, end): */
        middle = begin + (end - begin) / 2;
        if (key == array[middle])
            return middle;
        if (key < array[middle])
            /* Помимо array[middle],
             * отбрасываем все элементы, бОльшие array[middle]: */
            end = middle;
        else
            /* Помимо array[middle],
             * отбрасываем все элементы, меньшие array[middle]: */
            begin = middle + 1;
    }

    /* Если key не найден в array, возвращаем индекс послеконечного
     * элемента: */
    return savedEnd;
}

int main() {
    constexpr int N = 18;
    int array[N] = {47543, 32, 271, 0 , -1, 54, -243, 2473, -74237 , 24728, -532, 47, 0, -1, 4, 77, 77, 77};
    quickSort::threeWaySort(array, 0, N);
    for (int element: array)
        std::cout << element << ' ';
    std::cout << '\n';

    std::cout << "47 is found at: " << binarySearch(array, 0, N, 47) << '\n';
    return 0;
}
