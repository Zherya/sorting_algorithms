
#ifndef SORTING_ALGORITHMS_SORTING_ALGORITHMS_HPP
#define SORTING_ALGORITHMS_SORTING_ALGORITHMS_HPP

/*! @todo Переделать шаблонные параметры с использованием концептов (concept) C++20 */

#include <utility>
#include <iterator>

/* Так как для инстанциации определения сущности компиляторам C++
 * необходимо сначала обработать определение соответствующего шаблона,
 * то определения шаблонов необходимо разместить также в заголовочном файле. */

namespace sort {
/* ------------------------------------------------------------------------------------------------------- */
    /*! @brief Вспомогательная функция для определения степени отсортированности массива.
     *  Представляет собой алгоритм сортировки слиянием с подсчетом числа инверсий элементов
     *  (число элементов a[i] > a[j] для i < j).
     *
     * @tparam RandomAccessIterator  - должен удовлетворять требованиям
     * Random Access Iterator
     * (см. https://en.cppreference.com/w/cpp/named_req/RandomAccessIterator).
     * @param array - итератор на начало последовательности.
     * @param size - размер последовательности.
     * @return Возвращает число инверсий элементов в заданной последовательности.
     */
    template <typename RandomAccessIterator>
    static std::size_t mergeSortAndInversionsCount(RandomAccessIterator array, std::size_t size) {
        /* В тривиальном массиве нечего сортировать: */
        if (size <= 1)
            return 0;

        /* Размер левого массива: */
        std::size_t median = size / 2,
                inversionsCount = 0;
        /* Рекурсивный вызов для двух частей массива
         * отдельно: */
        inversionsCount += mergeSortAndInversionsCount(array, median);
        inversionsCount += mergeSortAndInversionsCount(array + median, size - median);

        /* Теперь в массиве содержатся две независимые
         * отсортированные части:
         * a[0], ..., a[median - 1] и
         * a[median], ..., a[size - 1].
         *
         * Теперь необходимо осуществить слияние этих
         * двух частей массива, создадим для этого
         * временный массив размера size. Определим тип значения
         * разыменованного итератора с помощью черт итераторов.
         * Это будет value_type для реальных итераторов контейнеров
         * или тип T для обычных указателей на массивы T *a. Ключевое слово
         * typename необходимо, так как имя типа зависит от параметров шаблона: */
        auto tmpArray = new typename std::iterator_traits<RandomAccessIterator>::value_type[size];

        /* Теперь осуществляем слияние двух подмассивов.
         * Просматриваем минимальные элементы каждого
         * подмассива, сравниваем их и записываем наименьший
         * из элементов в результирующий массив до тех пор,
         * пока оба массива еще не просмотрены. Затем просто
         * копируем оставшуюся часть оставшегося массива в результирующий.
         *
         * Индексы для каждого из подмассивов и временного массива: */
        std::size_t left = 0, right = median, tmpIndex = 0;
        while (left < median && right < size)
            if (array[left] > array[right]) {
                tmpArray[tmpIndex++] = std::move(array[right++]);
                /* Если элемент из левого подмассива больше
                 * элемента из правого подмассива, значит,
                 * имеет место инверсия (по определению).
                 * Поэтому этот и все оставшиеся элементы
                 * из левого подмассива больше данного элемента
                 * из правого: */
                inversionsCount += (median - left);
            }
            else
                tmpArray[tmpIndex++] = std::move(array[left++]);

        /* Если в каком-то подмассиве еще остались элементы,
         * скопируем их: */
        if (left < median)
            std::copy(std::make_move_iterator(array + left),
                      std::make_move_iterator(array + median), tmpArray + tmpIndex);

        if (right < size)
            std::copy(std::make_move_iterator(array + right),
                      std::make_move_iterator(array + size), tmpArray + tmpIndex);

        /* Наконец, копируем полностью отсортированный массив в исходный: */
        std::copy(std::make_move_iterator(tmpArray),
                  std::make_move_iterator(tmpArray + size), array);
        delete[] tmpArray;

        /* Возвращаем число инверсий: */
        return inversionsCount;
    }

/* ------------------------------------------------------------------------------------------------------- */
    /*! @brief Функция проверки отсортированности заданного массива.
     *
     * @tparam RandomAccessIterator  - должен удовлетворять требованиям
     * Random Access Iterator
     * (см. https://en.cppreference.com/w/cpp/named_req/RandomAccessIterator).
     * @param array - итератор на начало последовательности.
     * @param size - размер последовательности.
     * @param toSort - флаг, определяющий, нужно ли сортировать заданную последовательность.
     * Если toSort = true, то последовательность сортируется.
     * @param sortedPercentage - выходной параметр, в который записывается процент отсортированности
     * массива.
     * @return Возвращается true, если массив отсортирован, и false - иначе.
     */
    template <typename RandomAccessIterator>
    bool isSorted(RandomAccessIterator array, std::size_t size, bool toSort, double *sortedPercentage = nullptr) {
        /* Если массив содержит не более одного элемента,
         * то его можно считать отсортированным: */
        if (size <= 1) {
            if (sortedPercentage)
                *sortedPercentage = 100;
            return true;
        }

        std::size_t inversions;
        /* Если установлен флаг toSort, то мы вызываем
         * соответствующую функцию сортировки с подсчетом инверсий
         * на изначальном итераторе. */
        if (toSort)
            inversions = mergeSortAndInversionsCount(array, size);
        else {
            /* Иначе нужно создать новый массив и скопировать в
             * него значения изначального.
             * Определим тип элементов с помощью черт итераторов. */
            auto tmpArray = new typename std::iterator_traits<RandomAccessIterator>::value_type[size];
            std::copy(array, array + size, tmpArray);
            inversions = mergeSortAndInversionsCount(tmpArray, size);
            delete [] tmpArray;
        }

        /* Если необходимо вернуть процент отсортированности массива,
         * то сделаем это: */
        if (sortedPercentage) {
            std::size_t maxInversions = size * (size - 1) / 2;
            /* Крайние случаи для точного результата: */
            if (inversions == 0) {
                *sortedPercentage = 100;
                return true;
            }
            if (inversions == maxInversions) {
                *sortedPercentage = 0;
                return false;
            }
            /* 0 инверсий - это 100% - массив полностью отсортирован.
             * 1 инверсия - это 100 - 1 * (100/maxInversions) процентов.
             * 2 инверсии - это 100 - 2 * (100/maxInversions) процентов.
             * и т.д. */
            *sortedPercentage = 100. - inversions * (100. / maxInversions);
            return false;
        }
        else
            return inversions == 0;
    }

/* ------------------------------------------------------------------------------------------------------- */
    /*! @brief Алгоритм двоичного поиска - O(log(n)), где n = size.
     *
     * @tparam RandomAccessIterator  - должен удовлетворять требованиям
     * Random Access Iterator
     * (см. https://en.cppreference.com/w/cpp/named_req/RandomAccessIterator).
     * @tparam KeyType - типовой параметр для типа ключевого значения поиска.
     * @param array - итератор на начало последовательности.
     * @param begin - индекс начального элемента в диапазоне поиска [begin, end).
     * @param end - индекс послеконечного элемента в диапазоне поиска [begin, end).
     * @param key - ключевое значение, которое ищется в последовательности.
     *
     * @return Функция возвращает либо индекс i, для которого array[i] == key, либо
     * end, если такого индекса нет.
     */
    template <typename RandomAccessIterator, typename KeyType>
    std::size_t binarySearch(RandomAccessIterator array, std::size_t begin, std::size_t end, const KeyType &key) {
        std::size_t middle, savedEnd = end;
        while (begin < end) {
            /* Выбираем середину [begin, end): */
            middle = begin + (end - begin) / 2;
            if (key == array[middle])
                return middle;
            if (key < array[middle])
                /* Помимо array[middle],
                 * отбрасываем все элементы, бОльшие array[middle]: */
                end = middle;
            else
                /* Помимо array[middle],
                 * отбрасываем все элементы, меньшие array[middle]: */
                begin = middle + 1;
        }

        /* Если key не найден в array, возвращаем индекс послеконечного
         * элемента: */
        return savedEnd;
    }

/* ------------------------------------------------------------------------------------------------------- */
    /*! @brief Сортировка "Пузырьком" - O(n^2), где n = size.
     *
     * @tparam RandomAccessIterator - должен удовлетворять требованиям
     * Random Access Iterator
     * (см. https://en.cppreference.com/w/cpp/named_req/RandomAccessIterator).
     * @param array - итератор на начало последовательности.
     * @param size - размер последовательности.
     */
    template <typename RandomAccessIterator>
    void bubbleSort(RandomAccessIterator array, std::size_t size) {
        /* Индекс i (внешний цикл) определяет начало неотсортированной
         * части массива a[i],...,a[size-1], над
         * элементами которого производится обмен значений
         * с целью поиска наименьшего элемента, помещаемого на
         * позицию a[i]. Это означает, что элементы a[0],...,a[i-1]
         * уже отсортированы и находятся на своих конечных позициях: */
        for (std::size_t i = 0; i < size; ++i)
            /* Индекс j (внутренний цикл) определяет текущую для
             * сравнения и обмена пару элементов a[j-1] и a[j] в массиве
             * a[i],...,a[size-1], начиная с a[size-1] и a[size-2] и
             * далее, вплоть до элементов a[i+1] и a[i]: */
            for (std::size_t j = size - 1; j > i; --j)
                if (array[j - 1] > array[j])
                    /* Обмен значений элементов a[j-1] и a[j]: */
                    std::swap(array[j - 1], array[j]);
    }

/* ------------------------------------------------------------------------------------------------------- */
    /*! @brief Сортировка простыми вставками - O(n^2), где n = size.
     *
     * @tparam RandomAccessIterator  - должен удовлетворять требованиям
     * Random Access Iterator.
     * @param array - итератор на начало последовательности.
     * @param size - размер последовательности.
     */
    template <typename RandomAccessIterator>
    void insertionSort(RandomAccessIterator array, std::size_t size) {
        /* Индекс i (внешний цикл) определяет следующий
         * для сравнения элемент a[i], то есть это означает,
         * что первые i элементов a[0],...,a[i-1]
         * уже отсортированы между собой: */
        std::size_t i;
        /* Индекс j (внутренний цикл) определяет текущий
         * элемент из элементов a[0],...,a[i-1], с которыми
         * сравнивается проверяемый элемент a[i], а также,
         * по результатам сравнений, содержит индекс нового
         * места вставки проверяемого элемента a[i]: */
        std::size_t j;
        /* Определим тип значения разыменованного итератора с помощью черт
         * итераторов. Это будет value_type для реальных итераторов контейнеров
         * или тип T для обычных указателей на массивы T *a. Ключевое слово
         * typename необходимо, так как имя типа зависит от параметров шаблона: */
        typename std::iterator_traits<RandomAccessIterator>::value_type checkingVal;
        for (i = 1; i < size; ++i)
            /* Проверяем, стоит ли элемент a[i] на своем месте,
             * если нет, то ищем для него новое место
             * (собственно, выполняем итерацию алгоритма): */
            if (array[i] < array[i - 1]) {
                /* Сохраняем проверяемый элемент a[i] во временном объекте
                 * и перемещаем на его место a[i - 1], который больше a[i]:*/
                checkingVal = std::move(array[i]);
                array[i] = std::move(array[i - 1]);
                j = i - 1;
                /* Ищем нужное место для a[i] в отсортированном
                 * массиве a[0],...,a[i-1] (перемещаемся от большего
                 * элемента a[i-1] (уже проверенного) к меньшему, вплоть
                 * до a[0]). Попутно сдвигаем "вправо" (к большему индексу)
                 * элементы a[j], которые больше a[i], тем самым в конце цикла
                 * освобождая найденное места вставки (a[j]) для элемента a[i]: */
                while (j && checkingVal < array[j - 1]) {
                    array[j] = std::move(array[j - 1]);
                    --j;
                }
                /* Вставляем a[i] в найденное место a[j]
                 * (это либо a[0] при j = 0, либо место после
                 * элемента a[j - 1], меньшего или равного a[i]): */
                array[j] = std::move(checkingVal);
            }
    }

/* ------------------------------------------------------------------------------------------------------- */
    /*! @brief Сортировка выбором - O(n^2), где n = size.
     *
     * @tparam RandomAccessIterator  - должен удовлетворять требованиям
     * Random Access Iterator.
     * @param array - итератор на начало последовательности.
     * @param size - размер последовательности.
     */
    template <typename RandomAccessIterator>
    void selectionSort(RandomAccessIterator array, std::size_t size) {
        std::size_t indexOfMin;
        /* В начале каждой итерации внешнего цикла i определяет
         * правую открытую границу левой части a[0], ..., a[i-1]
         * массива, которая уже является окончательно отсортированной: */
        for (std::size_t i = 0; i < size; ++i) {
            /* На каждой итерации мы ищем минимальный элемент
             * среди неотсортированной правой части a[i], ..., a[size - 1]
             * массива, перемещая его на место a[i], тем самым увеличивая
             * левую отсортированную часть массива на один элемент: */
            indexOfMin = i;
            /* Внутренний цикл по поиску минимального элемента среди
             * a[i], ..., a[size - 1]: */
            for (std::size_t j = i + 1; j < size; ++j)
                if (array[j] < array[indexOfMin])
                    indexOfMin = j;
            /* Меняем местами a[i] и a[indexOfMin]: */
            std::swap(array[i], array[indexOfMin]);
        }
    }

/* ------------------------------------------------------------------------------------------------------- */
    /*! @brief Сортировка слиянием - O(n*log(n)), где n = size.
     *
     * @tparam RandomAccessIterator  - должен удовлетворять требованиям
     * Random Access Iterator.
     * @param array - итератор на начало последовательности.
     * @param size - размер последовательности.
     */
    template <typename RandomAccessIterator>
    void mergeSort(RandomAccessIterator array, std::size_t size) {
        /* В тривиальном массиве нечего сортировать: */
        if (size <= 1)
            return;

        /* Размер левого массива: */
        std::size_t median = size / 2;
        /* Рекурсивный вызов для двух частей массива
         * отдельно: */
        mergeSort(array, median);
        mergeSort(array + median, size - median);

        /* Теперь в массиве содержатся две независимые
         * отсортированные части:
         * a[0], ..., a[median - 1] и
         * a[median], ..., a[size - 1].
         *
         * Теперь необходимо осуществить слияние этих
         * двух частей массива, создадим для этого
         * временный массив размера size. Определим тип значения
         * разыменованного итератора с помощью черт итераторов.
         * Это будет value_type для реальных итераторов контейнеров
         * или тип T для обычных указателей на массивы T *a. Ключевое слово
         * typename необходимо, так как имя типа зависит от параметров шаблона: */
        auto tmpArray = new typename std::iterator_traits<RandomAccessIterator>::value_type[size];


        /* Теперь осуществляем слияние двух подмассивов.
         * Просматриваем минимальные элементы каждого
         * подмассива, сравниваем их и записываем наименьший
         * из элементов в результирующий массив до тех пор,
         * пока оба массива еще не просмотрены. Затем просто
         * копируем оставшуюся часть оставшегося массива в результирующий.
         *
         * Индексы для каждого из подмассивов и временного массива: */
        std::size_t left = 0, right = median, tmpIndex = 0;
        while (left < median && right < size)
            if (array[left] < array[right])
                tmpArray[tmpIndex++] = std::move(array[left++]);
            else
                tmpArray[tmpIndex++] = std::move(array[right++]);

        /* Если в каком-то подмассиве еще остались элементы,
         * скопируем их: */
        if (left < median)
            std::copy(std::make_move_iterator(array + left),
                      std::make_move_iterator(array + median), tmpArray + tmpIndex);
        if (right < size)
            std::copy(std::make_move_iterator(array + right),
                      std::make_move_iterator(array + size), tmpArray + tmpIndex);

        /* Наконец, копируем полностью отсортированный массив в исходный: */
        std::copy(std::make_move_iterator(tmpArray),
                  std::make_move_iterator(tmpArray + size), array);
        delete[] tmpArray;
    }

/* ------------------------------------------------------------------------------------------------------- */
    /*! @brief Класс, реализующий семейство алгоритмов быстрой сортировки - O(n*log(n)),
     * где n = size из функций @refitem sort() или @refitem threeWaySort().
     */
    class quickSort {
        /*! @brief Алгоритм разделения массива на две части по опорному элементу.
         *  В качестве опорного элемента выбирается элемент array[size - 1].
         *  В результате опорный элемент занимает свое финальное положение
         *  в массиве; слева от него будут расположены элементы, не превосходящие
         *  опорный, а справа - превосходящие. Ассимптотика - O(size).
         *
         * @tparam RandomAccessIterator  - должен удовлетворять требованиям
         * Random Access Iterator.
         * @param array - итератор на начало последовательности.
         * @param size - размер последовательности.
         *
         * @return Индекс опорного элемента из диапазона [0, size).
         */
        template <typename RandomAccessIterator>
        static std::size_t partition(RandomAccessIterator array, std::size_t size);

        /*! @brief Алгоритм разделения массива на три части по опорному элементу.
         *  Аналогично фукнции @refitem partition(), но помимо опорного элемента
         *  финальное положение занимают все элементы, равные опорному.
         *
         * @tparam RandomAccessIterator  - должен удовлетворять требованиям
         * Random Access Iterator.
         * @param array - итератор на начало последовательности.
         * @param size - размер последовательности.
         * @param pivotBeg - выходной параметр, в который записывается
         * индекс нулевого элемента диапазона, содержащего только
         * элементы, равные опорному.
         * @param pivotEnd - выходной параметр, в который записывается
         * индекс послеконечного элемента диапазона, содержащего только
         * элементы, равные опорному. Т.е. указанный диапазон имеет вид
         * [pivotBeg, pivotEnd).
         */
        template <typename RandomAccessIterator>
        static void threeWayPartition(RandomAccessIterator array, std::size_t size,
                                      std::size_t &pivotBeg, std::size_t &pivotEnd);

        /*! @brief Функция используется для генерации случайного индекса
         *  опорного элемента массива из диапазона [min, max].
         *
         * @param min - левая закрытая граница диапазона.
         * @param max - правая закрытая граница диапазона.
         *
         * @return Случайное целочисленное значение из диапазона [min, max].
         */
        static std::size_t randomPivot(std::size_t min, std::size_t max);

    public:
        /*! @brief Функция, реализующая алгоритм быстрой сортировки
         *  с ассимптотикой O(n*log(n)), где n = size.
         *
         * @tparam RandomAccessIterator  - должен удовлетворять требованиям
         * Random Access Iterator.
         * @param array - итератор на начало последовательности.
         * @param size - размер последовательности.
         */
        template <typename RandomAccessIterator>
        static void sort(RandomAccessIterator array, std::size_t size);

        /*! @brief Функция, реализующая алгоритм трехнаправленной (three way)
         *  быстрой сортировки с ассимптотикой O(n*log(n)), где n = size.
         *  Данный алгоритм эффективен для массивов со множеством
         *  равных элементов.
         *
         * @tparam RandomAccessIterator  - должен удовлетворять требованиям
         * Random Access Iterator.
         * @param array - итератор на начало последовательности.
         * @param size - размер последовательности.
         */
        template <typename RandomAccessIterator>
        static void threeWaySort(RandomAccessIterator array, std::size_t size);
    };

/* ------------------------------------------------------------------------------------------------------- */
    template <typename RandomAccessIterator>
    std::size_t quickSort::partition(RandomAccessIterator array, std::size_t size) {
        /* В качестве опорного выбирается последний элемент массива: */
        std::size_t pivot = size - 1;
        /* Индекс j обозначает правую открытую границу левого подмассива исходного
         * массива, элементы которого не превосходят опорный элемент, т.е. все
         * элементы a[0], ..., a[j - 1] не больше опорного элемента.
         * j = 0 означает, что данный подмассив пуст. */
        std::size_t j = 0;
        /* Индекс i обозначает элемент a[i], который сравнивается с опорным на
         * данной итерации. Также i обозначает правую открытую границу правого подмассива
         * исходного массива, элементы которого больше опорного элемента. При этом во
         * время цикла индекс j обозначает левую границу данного подмассива,
         * т.е. все элементы a[j], ...., a[i - 1] больше опорного элемента.
         * Индекс i изменяется от 0 до size - 2, пробегая от начального до
         * предпоследнего элемента, соответственно: */
        for (std::size_t i = 0, last = size - 1; i < last; ++i)
            /* Если a[i] больше опорного, то он уже в нужном подмассиве,
             * и в конце итерации индекс i увеличится соответствующим образом,
             * увеличив тем самым на единицу размер правого подмассива, тогда
             * как размер левого подмассива не изменяется. */
            if (array[i] <= array[pivot]) {
                /* Иначе элемент a[i] не больше опорного, поэтому необходимо
                 * переместить его в соответствующий левый подмассив.
                 * Поменяем местами элемент a[i] с элементом a[j],
                 * обозначающим первый элемент правого подмассива, а
                 * затем увеличим индекс j: */
                std::swap(array[i], array[j]);
                /* Увеличиваем индекс j, в результате чего значение,
                 * изначально содержащееся в a[i], теперь будет находиться
                 * в левом подмассиве в крайнем элементе a[j - 1], а крайнее левое значение
                 * из правого подмассива, с которым мы обменяли значение a[i], все так
                 * же будет входить в правый подмассив, но теперь как крайнее правое.
                 * В результате увеличения в конце итерации индекса i получаем, что
                 * размер правого подмассива не изменился, но его расположение сместилось на элемент
                 * вправа, тогда как размер левого подмассива увеличился на единицу. */
                ++j;
            }

        /* Получили два подмассива:
         * элементы a[0], ..., a[j - 1] не больше опорного a[size - 1],
         * а элементы a[j], ..., a[size - 2] больше опорного a[size - 1].
         * Поменяем местами a[j] и опорный a[size - 1], тем самым поместив
         * опорный элемент на конечное для него место a[j], как раз между
         * двумя подмассивами a[0], ...,a[j - 1] и a[j + 1], ..., a[size - 1]: */
        std::swap(array[j], array[size - 1]);

        /* Возвращаем индекс опорного элемента: */
        return j;
    }

/* ------------------------------------------------------------------------------------------------------- */
    template <typename RandomAccessIterator>
    void quickSort::threeWayPartition(RandomAccessIterator array, std::size_t size,
                                      std::size_t &pivotBeg, std::size_t &pivotEnd) {
        /* В качестве опорного выбирается последний элемент массива: */
        std::size_t pivot = size - 1;
        /* Индекс j обозначает правую открытую границу левого подмассива исходного
         * массива, элементы которого не превосходят опорный элемент, т.е. все
         * элементы a[0], ..., a[j - 1] не больше опорного элемента.
         * j = 0 означает, что данный подмассив пуст. EqualsNum означает
         * число элементов в конце этого подмассива, которые равны опорному: */
        std::size_t j = 0, equalsNum = 0;
        /* Индекс i обозначает элемент a[i], который сравнивается с опорным на
         * данной итерации. Также i обозначает правую открытую границу правого подмассива
         * исходного массива, элементы которого больше опорного элемента. При этом во
         * время цикла индекс j обозначает левую границу данного подмассива,
         * т.е. все элементы a[j], ...., a[i - 1] больше опорного элемента.
         * Индекс i изменяется от 0 до size - 2, пробегая от начального до
         * предпоследнего элемента, соответственно: */
        for (std::size_t i = 0, last = size - 1; i < last; ++i)
            /* Если a[i] больше опорного, то он уже в нужном подмассиве,
             * и в конце итерации индекс i увеличится соответствующим образом,
             * увеличив тем самым на единицу размер правого подмассива, тогда
             * как размер левого подмассива не изменяется. */
            if (array[i] <= array[pivot]) {
                /* Иначе элемент a[i] не больше опорного, поэтому необходимо
                 * переместить его в соответствующий левый подмассив.
                 * Поменяем местами элемент a[i] с элементом a[j],
                 * обозначающим первый элемент правого подмассива, а
                 * затем увеличим индекс j: */
                std::swap(array[i], array[j]);
                /* Увеличиваем индекс j, в результате чего значение,
                 * изначально содержащееся в a[i], теперь будет находиться
                 * в левом подмассиве в крайнем элементе a[j - 1], а крайнее левое значение
                 * из правого подмассива, с которым мы обменяли значение a[i], все так
                 * же будет входить в правый подмассив, но теперь как крайнее правое.
                 * В результате увеличения в конце итерации индекса i получаем, что
                 * размер правого подмассива не изменился, но его расположение сместилось на элемент
                 * вправа, тогда как размер левого подмассива увеличился на единицу. */
                ++j;
                /* Дополнительно проверяем, равен ли перемещенный элемент опорному: */
                if (array[j - 1] == array[pivot])
                    /* Если да, то увеличиваем число таких элементов и ничего больше
                     * не делаем, так как он уже находится на своем месте. */
                    ++equalsNum;
                else
                if (equalsNum) {
                    /* Иначе, при условии, что в левом подмассиве уже есть элементы,
                     * равные опорному (они стоят в правой его части), и новый
                     * перемещенный элемент не равен опорному,
                     * то этот элемент необходимо переместить левее всех равных опорному.
                     * Для этого поменяем его местами с первым, равным опорному: */
                    std::swap(array[j - 1], array[j - 1 - equalsNum]);
                }
            }

        /* Получили три подмассива:
         * элементы a[0], ..., a[j - 1 - equalsNum] меньше опорного a[size - 1];
         * элементы a[j - equalsNum], ..., a[j - 1] равны опорному a[size - 1];
         * элементы a[j], ..., a[size - 2] больше опорного a[size - 1].
         *
         * Поменяем местами a[j] и опорный a[size - 1], тем самым поместив
         * опорный элемент на конечное для него место a[j], как раз между
         * подмассивами a[j - equalsNum], ...,a[j - 1] и a[j + 1], ..., a[end - 1]: */
        std::swap(array[j], array[size - 1]);

        /* Возвращаем индексы на начальный и послеконечный элементы
         * подмассива "опорных элементов": */
        pivotBeg = j - equalsNum;
        pivotEnd = j + 1;
    }

/* ------------------------------------------------------------------------------------------------------- */
    template <typename RandomAccessIterator>
    void quickSort::sort(RandomAccessIterator array, std::size_t size) {
        std::size_t pivot;
        /* Если массив состоит хотя бы из двух элементов: */
        while (size >= 2) {
            /* partition выбирает в качестве опорного последний элемент массива,
             * поэтому выберем случайно индекс опорного и поместим элемент
             * с этим индексом на место последнего. Случайность выбора опорного
             * элемента позволяет максимизировать вероятность того, что массив
             * будет разбиваться на примерно равные части, что обеспечит оптимальную
             * ассимптотику работы алгоритма. */
            pivot = randomPivot(0, size - 1);
            std::swap(array[pivot], array[size - 1]);
            /* Разбиваем массив по опорному элементу и получаем индекс опорного: */
            pivot = partition(array, size);

            /* Чтобы ограничить требуемую для рекурсивных вызовов память
             * до O(log(n)) в худшем случае, мы будем итеративно вызывать
             * сортировку каждого подмассива (сначала первый, потом второй
             * или наборот). На каждой из итерации мы будем выбирать для сортировки
             * сначала тот подмассив, длина которого короче, что обеспечит нам
             * наименьшую глубину рекурсии: */
            if (pivot < (size - pivot - 1)) {
                /* Подмассив a[0], ..., a[pivot - 1]: */
                sort(array, pivot);
                /* Сдвигаем итератор начального элемента
                 * и уменьшаем размер массива,
                 * чтобы на следующей итерации обработать правый
                 * подмассив: */
                array += pivot + 1;
                size -= pivot + 1;
            } else {
                /* Подмассив a[pivot + 1], ..., a[size - 1]: */
                sort(array + pivot + 1, size - (pivot + 1));
                /* Изменяем размер массива,
                 * чтобы на следующей итерации обработать левый
                 * подмассив: */
                size = pivot;
            }
        }
    }

/* ------------------------------------------------------------------------------------------------------- */
    template <typename RandomAccessIterator>
    void quickSort::threeWaySort(RandomAccessIterator array, std::size_t size) {
        std::size_t pivotBegin, pivotEnd;
        /* Если массив состоит хотя бы из двух элементов: */
        while (size >= 2) {
            /* partition выбирает в качестве опорного последний элемент массива,
             * поэтому выберем случайно индекс опорного и поместим элемент
             * с этим индексом на место последнего. Случайность выбора опорного
             * элемента позволяет максимизировать вероятность того, что массив
             * будет разбиваться на примерно равные части, что обеспечит оптимальную
             * ассимптотику работы алгоритма. */
            std::swap(array[randomPivot(0, size - 1)], array[size - 1]);
            /* Разбиваем массив по опорному элементу и получаем индекс начального
             * и послеконечного элементов подмассива, содержащего только
             * элементы, равные опорному (a[pivotBegin],..., a[pivotEnd - 1]): */
            threeWayPartition(array, size, pivotBegin, pivotEnd);

            /* Чтобы ограничить требуемую для рекурсивных вызовов память
            * до O(log(n)) в худшем случае, мы будем итеративно вызывать
            * сортировку каждого подмассива (сначала первый, потом второй
            * или наборот). На каждой из итерации мы будем выбирать для сортировки
            * сначала тот подмассив, длина которого короче, что обеспечит нам
            * наименьшую глубину рекурсии: */
            if (pivotBegin < (size - pivotEnd)) {
                /* Подмассив a[0], ..., a[pivotBegin - 1]: */
                threeWaySort(array, pivotBegin);
                /* Сдвигаем итератор начального элемента
                 * и уменьшаем размер массива,
                 * чтобы на следующей итерации обработать правый
                 * подмассив: */
                array += pivotEnd;
                size -= pivotEnd;
            } else {
                /* Подмассив a[pivotEnd], ..., a[size - 1]: */
                threeWaySort(array + pivotEnd, size - pivotEnd);
                /* Изменяем размер массива,
                 * чтобы на следующей итерации обработать левый
                 * подмассив: */
                size = pivotBegin;
            }
        }
    }

/* ------------------------------------------------------------------------------------------------------- */
}

#endif //SORTING_ALGORITHMS_SORTING_ALGORITHMS_HPP
